{"./":{"url":"./","title":"首页","keywords":"","body":"首页 首页介绍 "},"source/zh-cn/overview/":{"url":"source/zh-cn/overview/","title":"1. 平台概述","keywords":"","body":"1.1 平台介绍 1.2 接入流程介绍 1.3 联系我们 "},"source/zh-cn/overview/platform_introduction.html":{"url":"source/zh-cn/overview/platform_introduction.html","title":"1.1平台介绍","keywords":"","body":"1.1 平台介绍 这里是平台介绍 "},"source/zh-cn/overview/access_flow_introduction.html":{"url":"source/zh-cn/overview/access_flow_introduction.html","title":"1.2接入流程介绍","keywords":"","body":"1.2 接入流程介绍 这里是接入流程介绍 "},"source/zh-cn/overview/contact_us.html":{"url":"source/zh-cn/overview/contact_us.html","title":"1.3联系我们","keywords":"","body":"1.3 联系我们 这里是联系我们 "},"source/zh-cn/product/":{"url":"source/zh-cn/product/","title":"2. 产品开发","keywords":"","body":"2.1 创建产品 2.2 协议配置 2.3 页面配置 2.4 设备调试 2.5 接入方案 2.6 联网配置 2.7 固件升级 2.8 MAC管理 2.9 发布产品 2.10 品牌管理 "},"source/zh-cn/product/product.html":{"url":"source/zh-cn/product/product.html","title":"2.1 创建产品","keywords":"","body":"2.1 创建产品 这里是创建产品内容 "},"source/zh-cn/product/protocol_config.html":{"url":"source/zh-cn/product/protocol_config.html","title":"2.2 协议配置","keywords":"","body":"2.2 协议配置 这里是协议配置内容 "},"source/zh-cn/product/page_config.html":{"url":"source/zh-cn/product/page_config.html","title":"2.3 页面配置","keywords":"","body":"2.3 页面配置 这里是页面配置内容 "},"source/zh-cn/product/debugging.html":{"url":"source/zh-cn/product/debugging.html","title":"2.4 设备调试","keywords":"","body":"2.4 设备调试 这里是设备调试内容爱 "},"source/zh-cn/product/access_scheme.html":{"url":"source/zh-cn/product/access_scheme.html","title":"2.5 接入方案","keywords":"","body":"2.5 接入方案 这里是接入方案内容 "},"source/zh-cn/product/network_config.html":{"url":"source/zh-cn/product/network_config.html","title":"2.6 联网配置","keywords":"","body":"2.6 联网配置 这里是联网配置内容 "},"source/zh-cn/product/upgrade.html":{"url":"source/zh-cn/product/upgrade.html","title":"2.7 固件升级","keywords":"","body":"2.7 固件升级 这里是固件升级内容 "},"source/zh-cn/product/mac.html":{"url":"source/zh-cn/product/mac.html","title":"2.8 MAC管理","keywords":"","body":"2.8 MAC管理 这里是MAC管理内容 "},"source/zh-cn/product/publish_product.html":{"url":"source/zh-cn/product/publish_product.html","title":"2.9 发布产品","keywords":"","body":"2.9 发布产品 这里是发布产品内容 "},"source/zh-cn/product/brand.html":{"url":"source/zh-cn/product/brand.html","title":"2.10 品牌管理","keywords":"","body":"2.10 品牌管理 这里是品牌管理内容 "},"source/zh-cn/app/":{"url":"source/zh-cn/app/","title":"3. APP开发","keywords":"","body":"1.1 android SDK 1.2 iOS SDK 1.3 H5 SDK "},"source/zh-cn/app/application/application.html":{"url":"source/zh-cn/app/application/application.html","title":"3.1 应用管理","keywords":"","body":""},"source/zh-cn/app/SDK/":{"url":"source/zh-cn/app/SDK/","title":"3.2 APP SDK","keywords":"","body":""},"source/zh-cn/app/SDK/android_sdk.html":{"url":"source/zh-cn/app/SDK/android_sdk.html","title":"3.2.1 android SDK","keywords":"","body":"Android SDK 概述 1.SDK功能简介 clife开放平台（以下简称开放平台）设备接入的SDK封装了clife对外开放的服务接口，以及手机与智能硬件通讯接口。包括用户模块，设备绑定模块，设备控制模块和其他的开放平台接口。开发者不需要关注这些模块的具体内部逻辑，只需要根据自己的业务需求编写界面和调用SDK接口就可以完成APP的快速开发。 下面是SDK的基础架构图： 2.相关名词定义 2.1.appId和appSecret 开放平台app的应用标识和密钥。开发者在开放平台接入设备创建APP的时候，后台会自动生成一个appId和appSecret。在初始化SDK的时候有用到。 2.2.硬件模组 这里的硬件模组是指的WIFI模组。在开放平台创建WIFI产品的时候需要指定设备的WIFI模组。在SDK初始化和APP在设备绑定的时候需要用到。 2.3.productId 设备产品号，设备在开放平台管理系统录入设备的时候，系统会根据设备录入的设备大类、设备小类、客户代码、DeviceKey、设备编码生成一个productId，可在开放平台管理系统上看到。 2.4.deviceId 设备号，当一个设备通过设备绑定的接口初次接入开放平台时，开放平台会自动根据productId以及设备的mac地址为此设备注册一个deviceId，此deviceId全网唯一，用于通过开放平台进行设备的操作。 3.SDK 快速开发，相关第三方库支持 3.1.RxJava 函数式编程 开放平台SDK 集成了RxJava。开发者可以根据自己的需要来使用，不需要自己再在项目中集成了。 3.2.RxBus 事件传递总线 开放平台SDK事件总线提供了RxBus的支持，开发者用于事件的发布和订阅来实现数据的传递，开发者可以根据项目需求来使用。使用实例： RxBus事件的发布： //发布 HetLoginSDKEvent.Login.LOGIN_SUCCESS 事件 RxManage.getInstance().post(HetLoginSDKEvent.Login.LOGIN_SUCCESS, object); RxBus事件的订阅： RxManage.getInstance().register(HetLoginSDKEvent.Login.LOGIN_SUCCESS, o -> { //订阅 HetLoginSDKEvent.Login.LOGIN_SUCCESS 事件 }); RxBus事件的取消订阅： RxManage.getInstance().unregister(HetLoginSDKEvent.Login.LOGIN_SUCCESS); 3.3.retrofit+okhttp 网络库的支持 开放平台SDK集成了retrofit+okhttp的网络库支持，开发者可以直接使用这个网络库来请求服务器数据。 3.4.ActiveAndroid 数据库支持 SDK集成了ActiveAndroid这个第三方的轻量级的数据库。开发者可以自己查阅资料直接使用，不需要再在项目中集成了。 3.5.X5内核 浏览服务的支持 SDK集成了X5内核的浏览服务，来提高H5的加载性能和兼容性。开发者在需要使用X5内核WebView的时候可以直接使用： 使用实例： 注意：将源码和XML里的系统包和类替换为SDK里的包和类，如：android.webkit.WebChromeClient 替换成 com.tencent.smtt.sdk.WebChromeClient 这样。 3.6.第三方服务平台的支持 SDK集成了第三方服务的库，支持微信、qq和新浪微博的分享和登录。使用简单方便，详细使用请查看 第三方平台服务的集成（登录和分享） 4.集成准备 4.1.注册开放平台账号 通过https://open.clife.cn/#/home注册一个开发者账号。登录到开放平台创建应用完善详细资料。此部分请参考《clife开发平台使用手册》。 创建产品之后创建APP获取到后台分配的appId和appSecret。 4.2.下载SDK终端DEMO 请前往下载中心下载最新SDK包。 4.3.在Android Studio上集成SDK，配置项目根目录build.gradle如下： allprojects { repositories { jcenter() //clife对外仓库 maven { url \"https://oss.sonatype.org/content/repositories/snapshots/\" } } } dependencies { //clifesdk库 compile 'com.github.szhittech:HetOpenSdk:1.0.7-SNAPSHOT' } 4.4.引用SDK到工程中 dependencies { compile fileTree(include: ['*.jar'], dir: 'libs') testCompile 'junit:junit:4.12' compile project(':HetOpenLib') compile 'com.android.support:appcompat-v7:23.0.1' compile 'com.android.support:support-v4:23.0.1' compile 'com.android.support:design:23.1.1' compile 'com.facebook.shimmer:shimmer:0.1.0@aar' compile 'com.facebook.fresco:fresco:0.8.1+' compile 'com.google.code.gson:gson:2.5' compile 'org.greenrobot:eventbus:3.0.0' compile 'com.readystatesoftware.systembartint:systembartint:1.0.3' compile 'com.github.szhittech:hetrecyclersdk:1.0.9-SNAPSHOT' //乐鑫信息科技(esptouchmodule) 模组ID：7 compile 'com.github.szhittech:esptouchmodule:1.0.1-SNAPSHOT' //clifeAP绑定(hetapmodule) 模组ID：28 compile 'com.github.szhittech:hetapmodule:1.0.1-SNAPSHOT' //clifesmartlink绑定(在庆科基础上修改 hetsmartlink) 模组ID：10 compile 'com.github.szhittech:hetsmartlink:1.0.1-SNAPSHOT' //科中龙(realtekmodule) 模组ID：4 compile 'com.github.szhittech:realtekmodule:1.0.1-SNAPSHOT' //新力维_NL6621底层库(xlwmodule) 模组ID：6 compile 'com.github.szhittech:xlwmodule:1.0.1-SNAPSHOT' //双驰达(sctechmodule) 模组ID：15 compile 'com.github.szhittech:sctechmodule:1.0.1-SNAPSHOT' //信驰达_MTK7681底层库(elianmodule) 模组ID：5 compile 'com.github.szhittech:elianmodule:1.0.1-SNAPSHOT' //Marvell(marvellmodule) 模组ID：v1=8，v2=27 compile 'com.github.szhittech:marvellmodule:1.0.1-SNAPSHOT' //博通(cooeemodule) 模组ID：20 compile 'com.github.szhittech:cooeemodule:1.0.1-SNAPSHOT' //二维码扫描 compile 'com.google.zxing:core:3.3.0' compile 'cn.bingoogolapple:bga-qrcodecore:1.1.8@aar' compile 'cn.bingoogolapple:bga-zxing:1.1.8@aar' } 引用SDK，根据自己硬件的模组来选择引用那个模组，其他的可以不用。 二维码扫描库在SDk demo中设备绑定中有用到，可以按照demoApp的实例来使用，也可以用自己的二维码扫描库。 4.5.配置AndroidManifest.xml 请将下面权限配置代码复制到 AndroidManifest.xml 文件中： 权限说明： 权限 用途 VIBRATE 允许设置时区的权限 CAMERA 相机权限 INTERNET 允许程序打开网络接口 WAKE_LOCK 电源管理 4.6.Android6.0系统文件读写权限设置 Android 6.0+新增了运行时权限动态检测，敏感权限必选要动态申请。开发者可以提供SDK提供的RxPermissions来动态申请权限 if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) { RxPermissions.getInstance(AppDelegate.getAppContext()) .request(Manifest.permission.READ_PHONE_STATE, Manifest.permission.WRITE_EXTERNAL_STORAGE ) .subscribe(grant -> { if (!grant) {//申请权限成功与否 finish(); } }); } SDK集成流程 1.SDK集成流程简介 第一步：SDK初始化(SDK的日志信息开关、环境设置、app主题的配置信息)第二步：授权登录和用户模块 (授权登录、获取用户信息、修改密码) 第三步：设备绑定 (WIFI设备的AP绑定和smartLink绑定 蓝牙的扫描绑定) 第四步：设备管理（获取设备列表、删除设备、设备分享） 第五步：设备控制（wifi和蓝牙设备的控制） 2.SDK初始化 第一步：在application里面初始化SDK。设置SDK的日志信息开关、环境设置、app主题的配置信息等 /** * 配置SKD * * @param appId * @param appSecret */ private void configApplication(String appId, String appSecret) { ConfigModel configModel = new ConfigModel(); configModel.setLog(true); //是否开启log信息 configModel.setHost(GlobalAddr.TYPE_PRODUCE_HOST); //环境设置 configModel.setH5UIconfig(UIJsonConfig.getInstance(this).getJsonString(UIJsonConfig.fileName, this)); //配置第三方登录 mLoginDelegate = new HetThirdDelegate.Builder(this) .registerQQ(UIJsonConfig.getTencentAppID()) .registerWeixin(UIJsonConfig.getWechatAppID(),UIJsonConfig.getWechatAppSecret()) .registerSinaWeibo(UIJsonConfig.getSinaAppID(), UIJsonConfig.getSinaAppSecret(), this.mSinaRedirectURL) .create(); HetSdk.getInstance().init(this, appId, appSecret, configModel); } 1、appId、appSecret是开发者在开发平台创建应用申请到的。2、HetThirdDelegate 这个是配置第三方登录（微信、QQ、新浪微博登录），需要的开发者自行配置，不需要的可以不要。关于第三方登录的集成请参考 3.3（SDK第三方登录的集成）。3、开发者可以自己去定义APP的配置configModel.setH5UIconfig(String h5UIconfig); h5UIconfig是定义的一个JSON字符串，demoAPP里面是通过assets/h5UIConfig.json来组装这个JSON字符串的。 接口调用请求说明SDK初始化接口 HetSdk.getInstance().init（） 参数说明 参数名称 是否必须 字段类型 参数说明 appId 是 string 应用标识 context 是 Context 上下文常量 secret 是 string 用户密匙 configModel 是 ConfigModel 初始配置 configModel说明 字段名称 字段类型 字段说明 isLog boolean 是否开启调试信息 host int 网络环境设置: 0x01：正式 0x02：预发布 0x03:内网 0x04：测试环境 H5UIconfig String APP初始配置 H5UIconfig配置说明SDK的授权登录页面需要这个JSON参数来配置，包括是否需要第三方登录，登录页面的样式等。可以参考SDk的DEMO工程通过assets/h5UIConfig.json的配置，以下给出配置详情： { \"app_id\": \"your_app_id\", \"app_secret\": \"your_app_app_secret\", \"navBackgroundColor\": \"FF3285FF\", \"navTitleColor\": \"FFFFFFFF\", \"logoshow\": true, \"loginBtnBackgroundColor\": \"FFFFFFFF\", \"loginBtnBorderColor\": \"FF5BA532\", \"loginBtnFontColor\": \"FF000000\", \"weiboLogin\": true, \"weixinLogin\": true, \"qqLogin\": true, \"copyRight\": \"\", \"privacyPolicy\": \"\", \"SMSTemplet\": \"\", \"tencent_app_id\": \"your_tencent_app_id\", \"wechat_app_id\": \"your_wechat_app_id\", \"wechat_app_secret\": \"your_wechat_app_secret\", \"sina_app_id\": \"your_sina_app_id\", \"sina_app_secret\": \"your_sina_app_secret\" } 字段说明： 字段名称 字段类型 字段说明 app_id String APP标识(可以在开放平台创建应用申请获得) app_secret String APP密钥(可以在开放平台创建应用申请获得) navBackgroundColor String 授权登录标题栏的背景色（例如：FF3285FF ） navTitleColor String 授权登录标题栏的文字颜色（例如：FFFFFFFF） logoshow boolean 授权登录页面的安全登录的图标是否显示（false，true） loginBtnBackgroundColor String 授权登录页面登录按钮背景颜色（例如：FFFFFFFF） loginBtnBorderColor String 授权登录页面登录按钮背景边框颜色（例如：FF5BA532） loginBtnFontColor String 授权登录页面登录按钮文字颜色（例如：FF000000） weiboLogin boolean 授权登录页面，是否显示微博登录（false，true） weixinLogin boolean 授权登录页面，是否显示微信登录（false，true） qqLogin boolean 授权登录页面，是否显示QQ登录（false，true） tencent_app_id String QQ登录的应用标识（可以在腾讯开放平台创建应用申请获得） wechat_app_id String 微信登录的应用标识（可以在微信开放平台创建应用申请获得） wechat_app_secret String 微信登录的应用密钥（可以在微信开放平台创建应用申请获得） sina_app_id String 新浪微博登录的应用标识（可以在新浪开放平台创建应用申请获得） sina_app_secret String 新浪微博的应用密钥（可以在新浪开放平台创建应用申请获得） copyRight String 保留字段 privacyPolicy String 保留字段 SMSTemplet String 保留字段 PS: 颜色值都使用argb的格式，前2位表示透明度，后6位是rgb颜色值。 第二步：在application注册模组 /** * 模组注册 */ private void registerModule() { try { ModuleManager.getInstance().registerModule(HeTApModuleImpl.class, getApplicationContext());//clifeAP绑定 ModuleManager.getInstance().registerModule(HeTSmartlinkImpl.class, getApplicationContext());//clifesmartlink绑定 ModuleManager.getInstance().registerModule(RealtekModuleImpl.class, getApplicationContext());//科中龙(realtekmodule) ModuleManager.getInstance().registerModule(XlwModuleImpl.class, getApplicationContext());//新力维_NL6621底层库 ModuleManager.getInstance().registerModule(SctechModuleImpl.class, getApplicationContext());//双驰达(sctechmodule) ModuleManager.getInstance().registerModule(ElianModuleImpl.class, getApplicationContext());//信驰达_MTK7681底层库 ModuleManager.getInstance().registerModule(MarvellV1WiFiImpl.class, getApplicationContext());//Marvell(marvellmodule) ModuleManager.getInstance().registerModule(MarvellV2WiFiImpl.class, getApplicationContext());//Marvell(marvellmodule) ModuleManager.getInstance().registerModule(EsptouchModuleImpl.class, getApplicationContext());//乐鑫信息科技(esptouchmodule) ModuleManager.getInstance().registerModule(CooeeModuleImpl.class, getApplicationContext());//博通(cooeemodule) } catch (Exception e) { e.printStackTrace(); } } 这里的模组注册是按需注册的。也就是根据自己的设备的模组类型来注册。 3.授权登录和用户模块 3.1.无私有服务器授权登录 SDK提供了HetNewAuthApi.getInstance().authorize方法可以直接跳转到授权登录页面。 /** * 授权登录 * * @param authCallback 回调 * @param specifyTitle 标题栏文字 * @param navigationBarTextColor 标题栏文字颜色 * @param navBackground 标题栏背景颜色 */ public void authorize(Context mContext, AuthCallback authCallback,String specifyTitle,int navigationBarTextColor,int navBackground) throws Exception { ... } protected void auth() { HetNewAuthApi.getInstance().authorize(activity, new AuthCallback() { @Override public void onSuccess(int code, String msg) { //登录成功 do something } @Override public void onFailed(int code, String msg) { //登录失败 do something } },\"授权登录\",Color.parseColor(\"#ff3285ff\")，Color.parseColor(\"#FFFFFFFF\")); } 授权登录页面： 3.2.云云对接用户授权登录 为了适应不同的业务需求，同时也考虑平台的安全问题SDK也提供了云云对接用户授权验证接口，该流程请参考文档C-Life开放平台验证码三方授权流程。 3.3.退出登录 退出登录SDK接口 HetSdk.getInstance().logout(); 退出登录之后记得发出通知APP相应的页面跳转到首页，并刷新到未登录的状态。 例如： public void logout() { new AlertDialog.Builder(activity) .setMessage(activity.getString(R.string.confirm_logout)) .setPositiveButton(activity.getString(R.string.logout_sure), (dialog, which) -> { dialog.dismiss(); if (HetSdk.getInstance().isAuthLogin()) { HetSdk.getInstance().logout(); RxManage.getInstance().post(HetLoginSDKEvent.Login.LOGINOUT_SUCCESS, \"\"); } }) .setNegativeButton(activity.getString(R.string.logout_cancel), null) .show(); } 使用判断是否处于登录状态，处于登录状态下，我们调用HetSdk.getInstance.logout(),并使用RxBus(开发者可以使用自己习惯的事件通知，如：event bus等)来发送通知到相应的页面来刷新页面状态。 如：接收退出登录的事件，刷新页面 RxManage.getInstance().register(HetLoginSDKEvent.Login.LOGINOUT_SUCCESS, o -> { //退出登录刷新页面 }); 3.4.判断登录状态 判断登录状态的接口 HetSdk.getInstance().isAuthLogin(); 3.5.异地登录 开放平台的账号只能在一台设备上面登录。当有账号在另一台设备登录时，SDK会抛出一个ECode.Token.EC_LOGINOUT的RxBus事件。 开发者可以在首页订阅这个事件，处理异地登录的逻辑。 例： RxManage.getInstance().register(ECode.Token.EC_LOGINOUT, s -> { //账号在其他设备登录，此时HetSdk.getInstance().isAuthLogin() 为false，跳转页面刷新到未登录状态。 ............. }); 3.6.获取用户信息 HetUserApi.getInstance().getUserMess()可以获取到用户信息 /** * 获取用户信息 * @param iCallback 回调 */ public void getUserMess(final IHetCallback iCallback) { ....... 调用实例： public void getUserInfo() { //账号登录之后才可以获取到用户信息，否则获取不到 if (!HetSdk.getInstance().isAuthLogin()) return; HetUserApi.getInstance().getUserMess(new IHetCallback() { @Override public void onSuccess(int code, String msg) { //获取用户信息成功 Type type = new TypeToken() { }.getType(); //users 包含账号的所有用户信息 UserInfoBean users = GsonUtil.getGsonInstance().fromJson(msg, type); } @Override public void onFailed(int code, String msg) { //获取用户信息失败 } }); } 接口返回UserInfoBean的用户详细参数说明： 参数名称 字段类型 参数说明 userId String 用户ID userName String 用户名称 email String 用户邮箱 sex number 性别（1-男，2-女） birthday String 生日（yyyy-MM-dd） weight number 体重（克） height number 身高（厘米） avatar String 头像URL city String 城市名 3.7.修改密码 调用 HetNewAuthApi.getInstance().alterPassword() 就会跳转到修改密码的页面。 /** * 修改密码 * @param mContext 上下文 * @param authCallback 回调 * @param phone 手机号 * @param specifyTitle 标题栏文字 * @param navigationBarTextColor 标题栏文字颜色 * @param navBackground 标题栏背景颜色 * @throws Exception */ public void alterPassword(Context mContext, AuthCallback authCallback, String phone,String specifyTitle,int navigationBarTextColor,int navBackground) throws Exception{ ............ } 这里手机号是需要通过获取用户信息之后才能得到的。这里有2种方式： 1、开发者可以登录成功之后就去获取用户信息，然后保存起来作为全局使用。（推荐使用） 2、在修改密码之前先调用获取用户信息的接口，获取到手机号之后再调用修改密码的接口。实例： public void editPwd(String phone) { if (!HetSdk.getInstance().isAuthLogin()) return; HetNewAuthApi.getInstance().alterPassword(activity, new AuthCallback() { @Override public void onSuccess(int code, String msg) { //修改密码成功 } @Override public void onFailed(int code, String msg) { //修改密码失败 } }, phone, \"修改密码\",Color.parseColor(\"#ff3285ff\")，Color.parseColor(\"#FFFFFFFF\")); } 修改密码页面： 4.设备绑定模块（添加设备） 开放平台的设备按照功能划分类型，设备有大类，大类下面划分不同型号的小类。确定类型之后，设备还有WIFI和蓝牙设备之分。绑定设备之前首先就需要选择设备类型在扫描绑定。WIFI SSID和密码 需要开发者自己去获取手机当前连接的WIFI，让用户自己输入WIFI密码之后再调用开始扫描绑定的接口，productId是设备小类中productId字段。WIFI设备AP绑定流程图如下： WIFI设备SmartLink绑定流程图如下： SDK的设备绑定非常简单，只需要知道设备的产品ID就可以进行绑定了开放平台提供了三种方式来获取产品ID。 第一种：拉取设备大类和设备小类（设备小类信息包含产品ID，也就是productId这个字段），具体分成2个步骤。第一步：获取设备大类型HetDeviceListApi.getInstance().getTypeList取APP支持绑定的设备大类型。调用实例： HetDeviceListApi.getInstance().getTypeList(new IHetCallback() { @Override public void onSuccess(int code, String s) { if (code == 0) { Type type = new TypeToken>() { }.getType(); //获取设备大类成功 刷新UI List models = GsonUtil.getGsonInstance().fromJson(list, type); ............ } } @Override public void onFailed(int code, String msg) { //获取设备大类列表失败 ............. } }); 第二步：获取设备小类型HetDeviceListApi.getInstance().getSubTypeListProduct获取APP支持绑定的设备大类型。通过选择的设备大类，查询大类下的小类列表。设备小类信息包含产品ID，也就是productId这个字段 HetDeviceListApi.getInstance().getSubTypeListProduct(new IHetCallback() { @Override public void onSuccess(int code, String msg) { if (code == 0) { Type type = new TypeToken>() { }.getType(); List models = GsonUtil.getGsonInstance().fromJson(list, type); } } @Override public void onFailed(int code, String msg) { ((BaseHetActivity) activity).showToast(msg); } }, deviceType);//deviceType 是大类类型 第二种：扫描开放平台创建的产品二维码来获取。扫描到的结果调用SDK的HetQrCodeApi的dealQrCode方法获取产品信息。产品信息包含了包含了产品ID //二维码规则 private void parseQrCodeVersion(String url) { String param = Uri.parse(url).getQueryParameter(\"param\"); if (TextUtils.isEmpty(param)) { tips(getResources().getString(R.string.qr_code_error)); } else { HetQrCodeApi.getInstance().dealQrCode(new IHetCallback() { @Override public void onSuccess(int code, String msg) { DeviceProductBean deviceProductBean = new Gson().fromJson(msg, DeviceProductBean.class); //获取到产品信息之后，按照第三步和第四步的流程来绑定 } @Override public void onFailed(int code, String msg) { tips(msg); finish(); } }, url); } } 第三种：在开放平台后台直接直接查看产品ID，详情请查《clife开发平台使用手册》。 开发者可以通过项目需要选择适合自己项目的方式来获取产品ID。在获取到产品ID之后，开发者只需要根据自己的设备类型来选择SDK的绑定接口就好了。具体可以分为WIFI绑定和蓝牙绑定2种。判断是WIFI设备还是蓝牙设备，进入相应的绑定页面，可以通过设备小类的moduleType字段来判断。如：int type = deviceSubModel.getModuleType(); type == 1标识WIFI设备 type ==2标识蓝牙设备。 下面对这2种绑定做具体说明WIFI设备绑定：SDK提供一个HetWifiBindApi接口,HetWifiBindApi里面有个startBind方法可以启动绑定。 /** * 开始绑定设备 * * @param ssid wifi名称 * @param wifiPassword wifi密码 * @param productId 产品ID * @param iWifiBind 绑定接口回调 */ public void startBind(Activity activity,String ssid,String wifiPassword, String productId, IWifiBind iWifiBind) { ............. } 使用实例： HetWifiBindApi.getInstance().startBind(this, sSidInfoBean.getSsid(), sSidInfoBean.getPass(), \"\" + currentDevice.getProductId(), new IWifiBind() { @Override public void onStatus(HetWifiBindState hetWifiBindState, String msg) { } @Override public void onFailed(int errId, String msg) { //绑定失败 显示失败界面 showBindFail(); } @Override public void onSuccess(DeviceModel deviceModel) { //绑定成功 显示成功界面 showBindSuccess(); } @Override public void onProgress(int type, int value) { //扫描绑定的进度 if(HetDeviceConstans.SCAN_PROGESS == type) {//扫描的进度 setTextProgress(value); }else if(HetDeviceConstans.BIND_PROGESS == type){//绑定的进度 showBindDialog(); } } }); BLE蓝牙设备绑定：SDK提供一个HetCommonBleBindApi接口，普通蓝牙设备可以扫描绑定.整个过程有2个步骤：第一步：扫描搜索周围设备；第二步：选择扫描的某个设备绑定到服务器；蓝牙网关设备绑定方式跟前面的方式有些小区别，两种方式的蓝牙设备绑定流程图如下： 具体的接口调用说明： HetCommonBleBindApi.getInstance().startBind(this, \"\" + deviceProductBean1.getProductId(), new ICommonBleBind() { @Override public void onScanDevices(int code, String devices) { if (code == 0) { Type type = new TypeToken>() { }.getType(); List scanDevices = GsonUtil.getGsonInstance().fromJson(devices, type); //获取到扫描到的蓝牙设备,显示扫描的设备列表。选择某一个设备之后调用 bindToServer绑定到服务器 showScanSucess(scanDevices); } } @Override public void onFailed(int errId, String msg) { //绑定失败 刷新界面 hideDialog(); showBindFail(); } @Override public void onSuccess(DeviceModel deviceModel) { //绑定成功 刷新界面 showBindSuccess(); } @Override public void onProgress(int type, int value) { if (HetDeviceConstans.SCAN_PROGESS == type) { //扫描进度 setTextProgress(value); } else if (HetDeviceConstans.BIND_PROGESS == type) {//绑定进度 showBindDialog(); } } }); //扫描到设备列表，选择其中一个设备，绑定到服务器 HetCommonBleBindApi.getInstance().bindToServer(deviceProductBean); 绑定无法绑定？这里给出设备无法绑定的几种检查方法： 设备是否置为绑定模式，是否在绑定的有效时间内是否正确输入wifi密码,请确认手机是否能正常连接网络是扫描不到设备还是绑定不了设备,扫描失败会有对应提示是扫描不到设备，还是绑定不了设备设备是否已在CLife开放平台注册，并按照要求将大小类信息写入设备中APP端服务是否开启（udpservice） 5.设备管理 5.1.设备model说明 SDK所有的设备devicemodel，参数说明 字段名称 字段类型 字段说明 deviceId string 设备标识 macAddress string MAC地址 deviceBrandId number 设备品牌标识 deviceBrandName string 设备品牌名称 deviceTypeId number 设备大分类标识 deviceTypeName string 设备大分类名称 deviceSubtypeId number 设备子分标识 deviceSubtypeName string 设备子分类名称 deviceName string 设备名称 roomId string 房间标识 roomName string 房间名称 authUserId string 授权设备用户标识 bindTime string 绑定时间 onlineStatus number 在线状态（1-正常，2-异常） share number 设备分享（1-是，2-否，3-扫描分享） controlType number 控制类型（1-原生，2-插件，3-H5插件） userKey string MAC与设备ID生成的KEY productId number 设备型号标识 productName string 设备型号名称 productCode string 设备型号编码 productIcon string 设备型号图标 moduleId number 模块标识 moduleType number 模块类型（1-WiFi，2-蓝牙，3-音频，4-GSM，5-红外） moduleName string 模块名称 radiocastName string 设备广播名 deviceCode string 设备编码 5.2.获取设备列表 HetDeviceListApi.getInstance().getBindList()获取设备列表，设备按照归属来划分有2种：第一种是用户自己绑定的设备。这类设备用户拥有这台设备的所有权限。第二种是别人分享给自己的设备。这类设备用户拥有控制权限，但是不可以再分享给其他人。 HetDeviceListApi.getInstance().getBindList(new IHetCallback() { @Override public void onSuccess ( int code, String s){ if (code == 0) { if (!TextUtils.isEmpty(s)) { Type type = new TypeToken>() { }.getType(); List models = GsonUtil.getGsonInstance().fromJson(list, type); //获取设备列表成功列表 } } } @Override public void onFailed ( int code, String msg){ //获取列表失败 } } 5.3.删除设备 设备删除有2中情况： 第一种：设备是用户自己绑定的设备。调用HetDeviceManagerApi.getInstance().unBind()来解除绑定。这里 deviceModel 是选择要删除的设备对象。 实例： HetDeviceManagerApi.getInstance().unBind(deviceModel, new IHetCallback() { @Override public void onSuccess(int code, String msg) { //解绑成功 } @Override public void onFailed(int code, String msg) { //解绑失败 } }); 第二种：设备是别人分享的过来的设备。调用HetDeviceShareApi.getInstance().deviceDel()方法来解绑分享关系。 实例： HetDeviceShareApi.getInstance().deviceDel(new IHetCallback() { @Override public void onSuccess(int code, String msg) { iHetCallback.onSuccess(code, msg); } @Override public void onFailed(int code, String msg) { iHetCallback.onFailed(code, msg); } }, deviceModel.getDeviceId(), null); 传入的参数是选择要删除的设备ID和当前用户的UserId。UserId直接传null就好了。传null表示被分享者解除分享关系，传userId表示设备拥有者回收这个用户的设备控制授权。 5.4.设备分享 5.4.1.获取设备授权的用户列表 调用HetDeviceShareApi.getInstance().getDeviceAuthUser()获取设备授权的用户列表，调用实例： HetDeviceShareApi.getInstance().getDeviceAuthUser(new IHetCallback() { @Override public void onSuccess(int code, String s) { if (code == 0) { Type type = new TypeToken>() { }.getType(); List deviceAuthUsers= GsonUtil.getGsonInstance().fromJson(s, type); //获取到设备授权的用户列表 ................. } } @Override public void onFailed(int code, String msg) { //获取设备授权的用户列表失败 } }, deviceId); DeviceAuthUserModel 的字段说明： 参数名称 字段类型 参数说明 userId String 用户ID userName String 用户名称 avatar String 用户头像 authTime String 授权时间 5.4.2.用户设备授权删除 调用HetDeviceShareApi.getInstance().deviceDel()就可以解除分享关系。 HetDeviceShareApi.getInstance().deviceDel(new IHetCallback() { @Override public void onSuccess(int code, String s) { if (code == 0) { //删除成功,刷新获取设备授权用户列表 ................... } } @Override public void onFailed(int code, String msg) { //删除失败 } }, deviceId, userId); 5.4.3.分享设备 分享的方式有2种，一种是面对面二维码分享，第二种远程第三方平台（微信 、QQ等）的分享。 注意：只要是用户账号自己绑定的设备才能分享给别人，别人分享给自己的设备是不能再分享出去的。下面对2中分享方式进行详细说明： 第一种：面对面分享，通过deviceId（要分享的设备的标识）获取分享码，分享的流程图如下： 具体的接口调用说明： /** * @param shareType 5是面对面分享 6远程分享 */ HetDeviceShareApi.getInstance().getShareCode(new IHetCallback() { @Override public void onSuccess(int code, String s) { if (code == 0) { Type treeType = new TypeToken() { }.getType(); ShareCodeModel codeModel = GsonUtil.getGsonInstance().fromJson(s, treeType); //分享邀请码获取成功 } } @Override public void onFailed(int code, String msg) { //分享邀请码获取失败 } }, deviceId, shareType); ShareCodeModel字段说明: 参数名称 字段类型 参数说明 shareCode String 设备分享码 （面对面分享） h5Url String H5 页面地址（远程分享） 开发者获取到分享码之后用二维码的形式展示出来。被分享的用户，通过二维码扫描到之后，调用设备授权的接口HetDeviceShareApi.getInstance().authShareDevice()就可以完成设备的分享了. HetDeviceShareApi.getInstance().authShareDevice(new IHetCallback() { @Override public void onSuccess(int code, String msg) { ToastUtil.showToast(mContext, \"设备分享成功\"); RxManage.getInstance().post(HetShareEvent.HET_EVENT_MAIN_SHARE_SUCCEE,null); } @Override public void onFailed(int code, String msg) { ToastUtil.showToast(mContext, \"设备分享失败\"); } }, code, \"5\");//5是面对面分享 6是远程分享 这里设备分享成功之后，抛出RxBus事件，设备列表页面注册事件之后刷新设备列表。 第二种：远程分享（通过QQ、微信分享设备）。 这种分享主要利用的是第三方社交平台，可以快速的实现设备分享有利于实现产品的快速推广。特别注意：远程的第三方分享一定要集成第三方分享服务。详细集成实例请参考下面 第三方平台服务的集成（登录和分享）的集成，跟第一种方式一样首先要获取分享码和分享的网页地址。分享的流程图如下： 具体的接口调用说明： HetDeviceShareApi.getInstance().getShareCode(IHetCallback callback,String deviceId,String shareType) deviceId传设备ID，shareType(5是面对面分享 6远程分享)。这里我们选择传\"6\",获取远程分享设备的分享地址。 HetDeviceShareApi.getInstance().getShareCode(new IHetCallback() { @Override public void onSuccess(int code, String s) { if (code == 0) { Type treeType = new TypeToken() { }.getType(); ShareCodeModel codeModel = GsonUtil.getGsonInstance().fromJson(s, treeType); //分享邀请码获取成功 String shareUrl = codeModel.getH5Url(); //调用第三分享接口把这个网页地址分享到第三方平台 ............. } } @Override public void onFailed(int code, String msg) { //分享邀请码获取失败 } }, deviceId, \"6\"); SDK提供了第三方分享的接口(暂时只支持微信，QQ，新浪微博)，实现第三方分享非常简单，只需要五步就可以完成： 第一步：集成第三方服务详细的集成流程请查看 第三方平台服务的集成（登录和分享） 第二步：初始化SKD第三方分享接口 HetThirdDelegate mShareManager = HetThirdDelegate.getInstance(); CommonShareProxy mShareProxy = new CommonShareProxy(this); mShareManager.setShareOperate(new CommonShareOperate(mContext)); mICommonShareListener = new ICommonShareListener() { @Override public void onStartShare(CommonSharePlatform sharePlatform) { CommonShareWebpage webpage = new CommonShareWebpage(sharePlatform); webpage.setUiListener(this); webpage.setTitle(\"设备分享\"); webpage.setDescription(\"设备分享，极速体验\"); webpage.setAppName(getString(R.string.app_name)); webpage.setTargetUrl(shareUrl); webpage.setWebpageUrl(shareUrl); webpage.setBm(BitmapFactory.decodeResource(mContext.getResources(), R.mipmap.icon_share)); webpage.setSharePlatform(sharePlatform); mShareManager.shareWebpage(webpage); } @Override public void onShareSuccess(CommonSharePlatform sharePlatform, String msg) { UserMessShareActivity.this.runOnUiThread(() -> { ToastUtil.showToast(mContext, \"分享成功\"); }); } @Override public void onShareFialure(CommonSharePlatform sharePlatform, String msg) { UserMessShareActivity.this.runOnUiThread(() -> { ToastUtil.showToast(mContext, \"分享失败\"); }); } @Override public void onShareCancel(CommonSharePlatform sharePlatform, String msg) { UserMessShareActivity.this.runOnUiThread(() -> { ToastUtil.showToast(mContext, \"分享取消\"); }); } }; 第二步：添加回调 @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (mShareManager != null && mShareProxy != null) { mShareProxy.onActivityResult(requestCode, resultCode, data); } } 第三步：开始分享 mICommonShareListener.onStartShare(CommonSharePlatform.WeixinFriend);//微信分享 mICommonShareListener.onStartShare(CommonSharePlatform.QQ_Friend);//QQ分享 分享类型有5种 public enum CommonSharePlatform { WeixinFriend,//微信好友 WeixinFriendCircle,//微信朋友圈 QQ_Friend,//QQ好友 QQ_Zone,//QQ空间 SinaWeibo;//新浪微博 ..... } 第四步：退出释放资源 @Override public void onDestroy() { super.onDestroy(); if (mShareManager != null) { mShareManager.releaseResource(); mShareManager = null; } } 6.设备控制 设备有WIFI设备的控制和蓝牙设备的控制区别，wifi设备控制流程图示如下： SDK提供统一的数据流接口。接收设备数据和监听设备状态都是通过IWifiDeviceData这个接口来完成，发送数据调用HetDeviceWifiControlApi.getInstance().setDataToDevice()。 IWifiDeviceData 的接口说明： public interface IWifiDeviceData { /** * 获取控制数据 * @param jsonData */ void onGetConfigData(String jsonData); /** * 获取运行数据 * @param jsonData */ void onGetRunData(String jsonData); /** * 获取异常数据 * @param jsonData */ void onGetErrorData(String jsonData); /** * 设备状态 * @param onlineStatus 在线状态（1-正常，2-异常不在线） */ void onDeviceStatues(int onlineStatus); /** * 收取数据异常 * @param code 错误码 * @param msg 错误信息 * 1000 无法连接服务器 * 1001 设备不在线 */ void onDataError(int code, String msg); } WIFI设备控制具体可以分成4个步骤：第一步：初始化 HetWifiDeviceControApi.getInstance().init(this, iWifiDeviceData); 第二步：设置接收设备数据的监听 HetWifiDeviceControApi.getInstance().start(deviceModel.getDeviceId(), deviceModel.getMacAddress()); private IWifiDeviceData iWifiDeviceData = new IWifiDeviceData() { @Override public void onGetConfigData(String jsonData) { //获取到设备上报控制数据 根据开放平台配置的协议解析成相应的数据 System.out.println(\"onGetConfigData: \" + jsonData); LedConfigModel configModel = GsonUtil.getInstance().toObject(jsonData, LedConfigModel.class); if (ledConfigModel != null) { ledConfigModel = configModel; } } @Override public void onGetRunData(String jsonData) { //获取到设备上报运行数据 根据开放平台配置的协议解析成相应的数据 System.out.println(\"onGetRunData: \" + jsonData); LedRunDataModel runDataModel = GsonUtil.getInstance().toObject(jsonData, LedRunDataModel.class); if (runDataModel != null) { ledRunDataModel = runDataModel; } } @Override public void onGetErrorData(String jsonData) { //获取到设备上报故障数据 根据开放平台配置的协议解析成相应的数据 System.out.println(\"onGetErrorData: \" + jsonData); } @Override public void onDeviceStatues(int onlineStatus) { } @Override public void onDataError(int code, String msg) { System.out.println(\"onDataError: \" + msg + \" code \" + code); } }; 开发者可以根据IWifiDeviceData 的回调接口来渲染UI。第三步：控制设备调用HetDeviceWifiControlApi.getInstance().setDataToDevice()发送控制数据到服务器。调用的时候把需要发送的控制数据组装好。 HetDeviceWifiControlApi.getInstance().setDataToDevice(new IHetCallback() { @Override public void onSuccess(int code, String msg) { } @Override public void onFailed(int code, String msg) { } }, deviceModel.getDeviceId(), GsonUtil.getInstance().toJson(ledConfigModel)); 第四步：释放资源在不需要控制设备的时候释放资源，例如在退出控制界面的时候，实例： @Override protected void onDestroy() { super.onDestroy(); HetWifiDeviceControApi.getInstance().stop(); } 注意:设备控制的时候会有一个updateFlag字段。这个字段标识是改变了那几个控制字段。 第二种 蓝牙设备控制：蓝牙设备控制主要是通过手机app和蓝牙设备先建立连接，然后根据定义的协议进行数据交互，具体的交互流程图如下： 具体的蓝牙控制分成5个步骤： 第一步：初始化HetCommonBleControlApi HetCommonBleControlApi.getInstance().init(this); 第二步：手机建立蓝牙连接,设置数据的收发回调 private void connect() { HetCommonBleControlApi.getInstance().connect(macAddress,connectCallback); } private final IConnectCallback connectCallback = new IConnectCallback() { @Override public void onConnectSuccess(BluetoothGatt gatt, int status) { conDevice.setText(\"连接成功\"); HookManager.getInstance().enableHook(true, \"fuck@academy\"); HookManager.getInstance().addHook(hookCallBack); } @Override public void onConnectFailure(final BleException exception) { conDevice.setText(\"连接失败\"); } @Override public void onDisconnect(String mac) { conDevice.setText(\"连接断开\"); } } IHookCallBack 监听发送数据和接收数据的回调。开发者可以在此监听app发送的数据和收到的设备数据。 private IHookCallBack hookCallBack = new IHookCallBack() { @Override public void onWrite(byte[] bytes) { showInfo(\"Send:\" + HexUtil.encodeHexStr(bytes)); } @Override public void onRead(byte[] bytes) { showInfo(\"Read:\" + HexUtil.encodeHexStr(bytes)); } @Override public void onReceived(byte[] bytes) { showInfo(\"Rec:\" + HexUtil.encodeHexStr(bytes)); } }; 备注:connect方法是允许重复调用的。对于已经连接的成功的连接，在此调用connect方法，SDK会直接返回连接成功不会再次去连接设备。 第三步：写数据SDK对开放平台蓝牙设备提供写数据的标准接口 HetCommonBleControlApi.getInstance().write()，调用实例： HetCommonBleControlApi.getInstance().write(macAddress,CmdIndexConstant.HET_COMMAND_BIND_APP,writeCallback); private IBleCallback writeCallback = new IBleCallback() { @Override public void onSuccess(HetOpenPlatformCmdInfo cmdInfo, int type) { //byte[] bytes = (byte[]) cmdInfo.getReceivePacket(); //showInfo(HexUtil.encodeHexStr(bytes)); } @Override public void onFailure(BleException exception) { showInfo(exception.getDescription()); } }; 第一个参数是设备mac。第二个参数是开放平台蓝牙协议标准接口类型。可以参照一下：CmdIndexConstant.HET_COMMAND_BIND_APP 绑定APPCmdIndexConstant.HET_COMMAND_GET_TIME_APP 获取设备时间CmdIndexConstant.HET_COMMAND_SET_TIME_APP 设置设备时间CmdIndexConstant.HET_COMMAND_GET_HISTORY_DATA_APP 获取设备历史数据CmdIndexConstant.HET_COMMAND_CLEAR_HISTORY_DATA_APP 清楚设备历史数据CmdIndexConstant.HET_COMMAND_GET_REAL_TIME_DATA_APP 获取真实时间CmdIndexConstant.HET_COMMAND_CONFIG_DATA_APP 下发控制协议第三个参数是写数据成功与否的监听回调。这里开发者可以自行做重发处理。 第四步：读数据SDK对开放平台蓝牙设备提供写数据的标准接口 HetCommonBleControlApi.getInstance().read()。SDK中提供了标准的获取设备信息的接口，调用实例: HetCommonBleControlApi.getInstance().read(macAddress,CmdIndexConstant.DeviceInfoConstant.HET_COMMAND_SYSTEM_ID,readCallback); private IBleCallback readCallback = new IBleCallback() { @Override public void onSuccess(HetOpenPlatformCmdInfo cmdInfo, int type) { byte[] bytes = (byte[]) cmdInfo.getReceivePacket(); String msg = \"Read:\" + ConvertUtil.convertHexToString(HexUtil.encodeHexStr(bytes)); //成功读取到设备数据 ............. } @Override public void onFailure(BleException exception) { //读取设备数据失败 ....... } }; 第一个参数是设备mac。第二个参数是开放平台蓝牙协议标准接口类型。可以参照一下：CmdIndexConstant.DeviceInfoConstant.HET_COMMAND_SYSTEM_ID System IdCmdIndexConstant.DeviceInfoConstant.HET_COMMAND_FIRMWARE_REVISION Firmware RevisionCmdIndexConstant.DeviceInfoConstant.HET_COMMAND_HARDWARE_REVISION Hardware RevisionCmdIndexConstant.DeviceInfoConstant.HET_COMMAND_SOFTWARE_REVISION Software RevisionCmdIndexConstant.DeviceInfoConstant.HET_COMMAND_SERIAL_NUMBER Serial NumberCmdIndexConstant.DeviceInfoConstant.HET_COMMAND_MANUFACTURE_NAME Manufacture Name（）CmdIndexConstant.DeviceInfoConstant.HET_COMMAND_MODEL_NUMBER Model NumberCmdIndexConstant.DeviceInfoConstant.HET_COMMAND_PNP_ID PnP IDCmdIndexConstant.DeviceInfoConstant.HET_COMMAND_BATTERY Battery Level第三个参数是读数据成功与否的监听回调。 第五步：释放资源(断开连接) HetCommonBleControlApi.getInstance().disConnect(macAddress); 7.其他接口 7.1.意见反馈 调用HetFeedbackApi.getInstance().addFeedback()提交意见反馈 /** * 意见反馈 * * @param iCallback the callback * @param contact 联系方式 可以传null匿名提交 * @param content 反馈内容 */ public void addFeedback(final IHetCallback iCallback, String contact, String content) { FeedbackDeal.addFeedback(iCallback, contact, content); } 7.2.消息模块 SDK提供了操作消息的接口HetMessageApi /** * 刷新列表 * * @param callback 回调 * @param messageId 消息ID * @param messageType 消息类型 * @param pageRows 每页数据大小 */ public void refreshList(IHetCallback callback, String messageId, String messageType, String pageRows) { .... } /** * 加载更多 * * @param callback 回调 * @param messageId 消息ID * @param messageType 消息类型 * @param pageRows 每页数据大小 */ public void loadList(IHetCallback callback, String messageId, String messageType, String pageRows) { .... } /** * 删除消息 * * @param callback 回调 * @param messageId 消息ID */ public void deleteMessage(IHetCallback callback, String messageId) { .... } /** * 消息标记为已读 * * @param callback 回调 * @param messageId 消息ID */ public void readMessage(IHetCallback callback, String messageId) { .... } /** * 消息标记为已读 * * @param callback 回调 * @param messageId 消息ID */ public void updateMsg(IHetCallback callback, String messageId) { .... } 开发者根据项目的需求来调用就可以了。下面对获取的消息列表做详细说明。调用HetMessageApi.getInstance().refreshList()获取消息列表，调用传参说明： 参数名称 是否必须 字段类型 参数说明 appId 是 string 应用标识 accessToken 是 string 访问凭证 timestamp 是 number 时间戳 messageId 否 number 消息标识，只有上拉时传值，下拉时不能传值 messageType 否 number 0-系统消息；1-添加好友；2-邀请控制设备；3-查看帖子评论；5-运营互动 selType 否 number 查询类型。按照人查询消息时不传值，按照app查询时，必传1 pageRows 否 number 每页数据大小 pageIndex 否 number 加载第几页 返回json结果： { \"data\": { \"pager\":{\"totalRows\":0, \"pageRows\":1, \"pageIndex\":1, \"paged\":false, \"defaultPageRows\":20, \"currPageRows\":0, \"pageStartRow\":0, \"hasPrevPage\":false, \"hasNextPage\":false, \"totalPages\":0, \"pageEndRow\":0}, \"list\": [{ \"messageId\":1, \"title\":\"特特特特\", \"description\":\"大声答答\", \"businessParam\":\"11111\", \"sender\":1, \"icon\":\"http://www.test.com\", \"createTime\":1434014367000, \"messageType\":1, \"status\":1， \"level2\":3, \"content\":\"http://200.200.200.50/clife_app/page/topic-view.html?type=2&id=927\", \"readed\":0, \"readonly\":0, \"summary\":null, \"pictureUrl\":null }] }, \"code\": 0 } 返回的结果字段说明： 字段名称 字段类型 字段说明 messageId number 消息标识 title string 标题 description string 描述 businessParam string 业务参数的值(系统推送消息对应消息详情URL(businessParam为空时不要跳转)；添加好友消息对应用户Id，控制设备消息对应设备ID，查看帖子评论对应帖子详情URL。） sender number 发送者ID icon string 图标URL messageType number 消息类型：0-系统消息；1-添加好友；2-邀请控制设备；3-查看帖子评论；5-运营互动；其他后续补充 createTime number 时间戳 status number 消息状态(0-删除；1-未处理；2-已处理) level2 number (系统消息的时候如果操作类标识)系统消息下的二级分类：1-无正文；2-文本H5；3-外链；4-设备 content String (表示设备信息时候建议接口调用时传json格式值)系统消息内容 readed number 消息是否已读（0-已读 1-未读） readonly number 消息是否只读（0-只读类 1-操作类） summary String 简要描述 pictureUrl String 简图路径 第三方平台服务的集成（登录和分享） 第三方登录和分享的集成，SDK目前只支持三种方式，也是目前比较主流的第三方平台。包括微信、QQ、和新浪微博。具体过程分4个步骤： 第一步：在集成之前需要在微信开放平台、腾讯开放平台、新浪开放平台创建应用，获取到相应的appID和appSecret。第二步：在Application里面配置第三方登录SDK。 //配置第三方登录 mLoginDelegate = new HetThirdDelegate.Builder(this) .registerQQ(\"your_qq_app_id\") .registerWeixin(\"your_weixin_app_id\", \"your_weixin_app_secret\") .registerSinaWeibo(\"your_sina_app_id\", \"your_sina_app_secret\", \"your_sina_redirect_url\"L) .create(); 注意：your_sina_redirect_url是新浪微博用于OAuth authorize页面回调的url。 第三步：配置清单文件AndroidManifest.xml 并添加相应的权限 第四步：设置微信登录的回调页面。在项目包名目录下添加一个wxapi目录在wxapi里面新建一个WXEntryActivity页面，如： public class WXEntryActivity extends Activity implements IWXAPIEventHandler { private IWXAPI api; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Logc.e(\"Weixin\", \"WXEntryActivity....onCreate\", false); api = WXAPIFactory.createWXAPI(this, UIJsonConfig.getWechatAppID(), true); api.registerApp(UIJsonConfig.getWechatAppID()); api.handleIntent(getIntent(), this); } @Override public void onReq(BaseReq arg0) { Logc.e(\"WXEntryActivity....onReq\", false); } @Override public void onResp(BaseResp resp) { Logc.e(\"WXEntryActivity....onResp\", false); if (resp instanceof SendAuth.Resp) { WeiXinLogin.getInstance().onResp(this, (SendAuth.Resp) resp); return; } this.finish(); } } 注意：wxapi和WXEntryActivity的位置和名字都不能改变，否则不能回调到app中来。例如:DEMO APP的包名是com.het.sdk.demo，那就WXEntryActivity的完整名称就是com.het.sdk.demo.wxapi.WXEntryActivity。新浪微博分享回调SDK已经集成，com.het.open.lib.wb.WBEntryActivity,开发者不需要关注。 全局返回码 全局返回码说明 每次调用接口时，可能获得正确或错误的返回码，可以根据返回码信息调试接口，排查错误。 全局返回码说明如下： 返回码 说明 0 请求成功 100010100 缺少授权信息 100010101 AccessToken错误或已过期 100010102 RefreshToken错误或已过期 100010103 AppId不合法 100010104 timestamp过期 100010105 签名错误 100010200 失败 100010201 缺少参数 100010202 参数错误 100010203 必须使用https 100010208 产品不存在 100021000 帐号已注册 100021001 帐号未注册 100021007 帐号已邀请 100021008 邀请你的用户已解绑该设备 100021010 邀请已被接受 100021301 验证码错误 100021302 随机码错误 100021303 您的访问太过频繁，请15分钟之后再尝试 100021304 重新获取验证码成功 100021401 用户不存在 100021500 密码错误 100021603 数据不存在 100022000 设备不存在 100022001 设备未绑定 100022002 设备已绑定 100022003 设备解绑失败 100022004 MAC地址已绑定另一种设备 100022005 设备控制JSON错误 100022006 设备不在线 10002208 不能邀请自己控制 100022011 设备已授权 100022012 待更换MAC与原MAC相同 100022013 appId与产品未做关联 100022014 待绑定MAC未进行服务注册 106000021 应用无权限查看该设备信息 106000026 产品不存在 106000031 应用包名错误 106000036 openId错误 106000037 手机号码错误 106000041 帐号错误，请使用开放平台账号登录 H5+Native混合框架 为了适应APP不断添加新的设备和动态更新，clife平台结合APP开发一套动态的插件更新框架。基于这套框架可以实现app功能的快速开发迭代，减少产品的上线周期。 1.H5开发框架 请参考 基于React的JS-SDK框架 2.Android和H5通讯 SDK提供了原生与H5通讯的管理接口HtmlFiveManager，其通讯原理图如下： public HtmlFiveManager(Activity activity, WebView wv, IAppJavaScriptsInterface appJavaScriptsInterface) { ........... } 第一个参数是当前的原生活动Activity第二个参数传入自己创建的webView。可以直接在activity的layout中创建，也可以直接new WebView(context);（推荐后者）第三个参数是给H5页面调用的接口 IAppJavaScriptsInterface。 public interface IAppJavaScriptsInterface { void send(String var1, IMethodCallBack var2); String getModeJson();//在H5调用het.config之后，原生会调用getModeJson（）把这个原生方法返回的数据通过ready()回调到H5的ready() 方法。 其实就是原生把H5加载完之后初始化需要展示的数据通过这个接口传递给H5。 void onWebViewCreate();//H5加载完之后调用原生方法 void tips(String var1);//H5调用het.toast就会回调到原生的tips()方法。这个方法建议直接弹原生的Toast。 void setTitle(String var1);//H5调用het.setTitle调用的原生的setTitle方法 void onLoadH5Failed(int var1, String var2);//当H5页面加载失败时回调原生的onLoadH5Failed方法 void h5SendDataToNative(int var1, String var2, String var3, IH5CallBack var4);//h5把数据发送到原生，提供回调 void h5GetDataFromNative(int var1, String var2, IH5CallBack var3);//h5获取原生的数据 } HtmlFiveManager提供了3个方法把获取到的设备数据提交到H5。updateConfigData()//提交控制数据updateRunData()//提交运行数据updateErrorData()//提交故障数据 H5可以通过JS-SDK 的 het.send方法把数据提交给原生IAppJavaScriptsInterface接口的send方法。原生只需实现这个send（）来处理H5提交的数据，如：把数据提交到服务器。 "},"source/zh-cn/app/SDK/ios.html":{"url":"source/zh-cn/app/SDK/ios.html","title":"3.2.2 iOS SDK","keywords":"","body":"iOS SDK 概述 目录 0、 设备接入SDK概述 1、 SDK初始化 2、 SDK授权 3、 SDK第三方登录 4、 SDK蓝牙设备的扫描绑定 5、 SDK蓝牙设备的控制 6、 SDK WIFI设备的扫描绑定 7、 SDK WIFI设备的控制 8、 SDK 设备的分享 9、 SDK APP辅助信息接口 设备接入SDK概述 一. SDK功能简介 clife开放平台（以下简称开放平台）设备接入的SDK封装了clife对外开放的服务接口，以及手机与智能硬件通讯接口。包括用户模块，设备绑定模块，设备控制模块和其他的开放平台接口。开发者不需要关注这些模块的具体内部逻辑，只需要根据自己的业务需求编写界面和调用SDK接口就可以完成APP的快速开发。 二. SDK的总体框架 三. 相关名词定义 3.1 大循环 智能设备通过路由器或直接接入互联网以实现用户的远程监测与控制，我们称为大循环。 3.2 productId 设备产品号，设备在开放平台管理系统录入设备的时候，系统会根据设备录入的设备大类、设备小类、客户代码、DeviceKey、设备编码生成一个productId，可在开放平台管理系统上看到。 3.3 deviceId 设备号，当一个设备通过设备绑定的接口初次接入开放平台时，开放平台会自动根据productId以及设备的mac地址为此设备注册一个deviceId，此deviceId全网唯一，用于通过开放平台进行设备的操作。 "},"source/zh-cn/app/SDK/iOSSDK/iOS_init.html":{"url":"source/zh-cn/app/SDK/iOSSDK/iOS_init.html","title":"3.2.2.1 初始化","keywords":"","body":"初始化 一、集成准备 1、 注册开放平台账号 在C-Life开发平台注册一个开发者账号。登录到开放平台创建应用完善详细资料。此部分请参考《C-Life开发平台使用手册》。 二、下载C-Life iOS SDK文件，并且配置工程 1、确认本机安装的cocoapods能正常工作 pod --help 2、编辑工程对于的Podfile文件 pod 'HETOpenSDK','0.1.1' 3、安装 以下两种方式任选一种就可以： 1.pod install 2.pod update 三、导入硬件模组对应的SDK 1、根据产品类型找到对应的芯片模组名称，如下： 2、在podfile中导入对应的sdk，并且安装，对应类表如下： # TI-WiFi模组 pod 'HETPublicSDK_WiFiModule_TI_CC3200R2', '1.0.0' # 汉枫-WiFi模组 pod 'HETPublicSDK_WiFiModule_HF_LPT100_V3', '1.0.0' # 科中龙-WiFi模组 pod 'HETPublicSDK_WiFiModule_Realtek8711AF', '1.0.0' # 信驰达-WiFi模组 pod 'HETPublicSDK_WiFiModule_MTK7681', '1.0.0' # 信驰达-WiFi模组 pod 'HETPublicSDK_WiFiModule_MTK7687', '1.0.1' # 新力维-WiFi模组 pod 'HETPublicSDK_WiFiModule_NL6621', '1.0.0' # 乐鑫-WiFi模组 pod 'HETPublicSDK_WiFiModule_ESP8266', '1.0.0' # COOEE-WiFi模组 pod 'HETPublicSDK_WiFiModule_COOEE', '1.0.0' # MarvellV2-WiFi模组 pod 'HETPublicSDK_WiFiModule_Marvell_MW300_V2', '1.0.0' 备注：在使用了Wifi模组后，就不再支持模拟器调试。 三、注册使用SDK 1、在AppDelegate 中如下地方添加，注册使用SDK，打开Log - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // 1.注册HET开发平台SDK [HETOpenSDK registerAppId:@\"yourAPPId\" appSecret:@\"yourAPPSecret\"]; [HETOpenSDK openLog:YES]; return YES; } yourAPPId、yourAPPSecret的值是在“应用创建”时生成的AppID、AppSecret。 在如下图查看: 注意:如果网络请求出现AppID不合法，请检查Xcode工程里面的BundleId和appId，必须跟在开放平台创建应用时填的BundleId和AppID保持一致。 "},"source/zh-cn/app/SDK/iOSSDK/iOS_Auth.html":{"url":"source/zh-cn/app/SDK/iOSSDK/iOS_Auth.html","title":"3.2.2.2 SDK授权","keywords":"","body":"授权登录 参考HETAuthorize类里面方法,调用authorizeWithCompleted接口会弹出授权登录的界面，登录成功后接口返回openId（授权用户唯一标识）可用于与自己平台的账户体系关联。 1、授权登录 /** * 是否授权认证 * * @return YES为已经授权登录 */ - (BOOL)isAuthenticated; /** * 授权认证 * * @param completedBlock 授权认证回调 */ - (void)authorizeWithCompleted:(authenticationCompletedBlock)completedBlock; 【示例代码】 HETAuthorize *auth = [[HETAuthorize alloc] init]; self.auth = auth; if (![self.auth isAuthenticated]) { [self.auth authorizeWithCompleted:^(NSString *openId, NSError *error) { }]; } 2、取消授权登录，退出当前账号 /** * 取消授权认证 */ - (void)unauthorize; 【示例代码】 // 在授权登录成功的情况才执行操作 if ([self.auth isAuthenticated]) { [self.auth unauthorize]; } 3、获取用户信息 /** *获取用户信息 * * @param success 获取用户信息成功的回调 * @param failure 获取用户信息失败的回调 */ -(void)getUserInformationSuccess:(successBlock)success failure:(failureBlock)failure; 接口返回的结果数据 { \"code\":0, \"data\":{ \"userId\": \"d09f572c60ffced144d6cfc55a6881b9\", \"userName\": \"葫芦娃\", \"email\":\"\", \"phone\":\"\", \"sex\": 1, \"birthday\": \"2014-12-31\", \"weight\": 48000, \"height\": 163, \"avatar\": \"\", \"city\": \"深圳\" } } 4、修改密码 /** 修改密码 @param success 成功 @param failure 失败 */ - (void)changePasswordSuccess:(successBlock)success failure:(failureBlock)failure; 5、异地登录、accessToken过期通知 开放平台的账号只能在一台设备上面登录。当有账号在另一台设备登录时，SDK会抛出一个HETLoginOffNotification消息。 开发者可以在首页监听这个消息，处理异地登录的逻辑。 例： [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(XXX) name:HETLoginOffNotification object: nil]; "},"source/zh-cn/app/SDK/iOSSDK/iOS_third_login.html":{"url":"source/zh-cn/app/SDK/iOSSDK/iOS_third_login.html","title":"3.2.2.3 SDK第三方登录","keywords":"","body":"第三方登录 一、申请各个平台的App key和App secret 注意：app bundleId跟各平台注册的时候一致。 微信接入地址 二、通过Pod导入SDK： pod 'WechatOpenSDK', '1.7.7' pod 'WeiboSDK', '3.1.3' pod 'TencentOpenApiSDK', '2.9.5' 三、项目配置 1、URLScheme 配置： 2、针对iOS9以后，需要添加白名单。 在info.plist文件中加入 LSApplicationQueriesSchemes LSApplicationQueriesSchemes wechat weixin sinaweibohd sinaweibo sinaweibosso weibosdk weibosdk2.5 mqqapi mqq mqqOpensdkSSoLogin mqqconnect mqqopensdkdataline mqqopensdkgrouptribeshare mqqopensdkfriend mqqopensdkapi mqqopensdkapiV2 mqqopensdkapiV3 mqzoneopensdk wtloginmqq wtloginmqq2 mqqwpa mqzone mqzonev2 mqzoneshare wtloginqzone mqzonewx mqzoneopensdkapiV2 mqzoneopensdkapi19 mqzoneopensdkapi mqzoneopensdk 3、针对iOS9默认使用https,现在先还原成http请求方式。 在Info.plist中添加NSAppTransportSecurity类型Dictionary。 在NSAppTransportSecurity下添加NSAllowsArbitraryLoads类型Boolean,值设为YES 第一步：在plist中添加NSAppTransportSecurity项，此项为NSDictionary 第二步：在NSAppTransportSecurity下添加 NSAllowsArbitraryLoads类型为Boolean，value为YES 四、接入HETOpenSDK 第三方登录 1. 在刚刚新建的项目中 appdelegate.m， 添加代码： a、注入appkey [HETOpenSDK setPlaform:HETAuthPlatformType_QQ appKey:QQ_APP_ID appSecret:nil redirectURL:nil]; [HETOpenSDK setPlaform:HETAuthPlatformType_Weibo appKey:WB_APP_KEY appSecret:nil redirectURL:nil]; [HETOpenSDK setPlaform:HETAuthPlatformType_Wechat appKey:WX_APP_KEY appSecret:WX_APP_SECRET redirectURL:nil]; b、在添加跳转的请求方法 - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { BOOL result = [HETOpenSDK application:application openURL:url sourceApplication:sourceApplication annotation:annotation]; return result; } - (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url { BOOL result = [HETOpenSDK handleOpenURL:url]; return result; } "},"source/zh-cn/app/SDK/iOSSDK/iOS_BLE_Scan_Bind.html":{"url":"source/zh-cn/app/SDK/iOSSDK/iOS_BLE_Scan_Bind.html","title":"3.2.2.4 SDK蓝牙设备的扫描绑定","keywords":"","body":"蓝牙扫描绑定 蓝牙的扫描绑定主要看HETBLEBusiness相关接口 一、扫描二维码绑定 扫描二维码绑定，即用户扫描设备的二维码来绑定设备的方式。 1、获取设备类型、确定设备绑定方式 通过扫一扫获取产品ID productId 根据 产品ID 获取设备信息 根据设备信息区分设备类型、设备绑定方式 a、获取产品ID 扫一扫内容： urlStr: http://open.clife.net/v1/web/open/product?param={\"a\":3531} \"a\":3531 3531 即是 产品ID b、根据 产品ID 获取设备信息 /** * 根据productId获取产品的详细信息 * * @param productId 设备型号标识 * @param success 查询设备信息成功的回调 * @param failure 查询设备信息失败的回调 */ +(void)fetchDeviceInfoWithProductId:(NSNumber *)productId success:(successBlock)success failure:(failureBlock)failure; 根据设备信息中的 moduleType 来区分设备类型 moduleType 绑定类型 1 wifi设备 SmartLink绑定 2 蓝牙设备 9 wifi设备 AP绑定 蓝牙设备只有一种绑定方式（蓝牙绑定） c、初始化HETBLEBusiness对象，启动绑定流程 //初始化蓝牙设备的业务类，需要设备的productId，deviceTypeId，deviceSubtypeId self.bleBusiness=[[HETBLEBusiness alloc] initWithProductId:self.productId.integerValue deviceTypeId:self.deviceTypeId.integerValue deviceSubtypeId:self.deviceSubtypeId.integerValue]; 扫描蓝牙设备,扫描到的蓝牙设备，用tableView显示出来，给用户选择。 WEAKSELF [self.bleBusiness scanForPeripheralsWithTimeOut:timeOut name:nil mac:nil scanForPeripheralsBlock:^(NSArray *peripherals, NSError *error) { if (error) { [weakSelf scanDeviceFail]; return ; } if (peripherals) { OPLog(@\"peripherals = %@\",peripherals); OPLog(@\"[NSThread currentThread] = %@\",[NSThread currentThread]); [peripherals enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { }]; return; } }]; d、绑定设备 选择需要绑定的设备，启动绑定流程。 [self.bleBusiness bindBleDeviceWithPeripheral:cbp macAddress:nil completionHandler:^(NSString *deviceId, NSError *error) { [weakself.bleBusiness disconnectWithPeripheral:cbp]; if(error) { } else { } }]; 二、手动绑定 获取设备大类列表 (获取deviceTypeId) 获取设备小类列表（支持的设备列表,其中含有productId,deviceSubtypeId） 传入参数productId，deviceTypeId，deviceSubtypeId，启动绑定流程 a、获取设备大类列表 在 HETDeviceRequestBusiness 查询设备信息获取相关接口 /** * 查询设备大类 * * @param success 成功的回调 * @param failure 失败的回调 */ + (void)fetchDeviceTypeListSuccess:(successBlock)success failure:(failureBlock)failure; b、通过大类ID，获取设备小类 /** * 根据设备大类查询APP支持的设备型号 * * @param success 成功的回调 * @param failure 失败的回调 */ + (void)fetchDeviceProductListWithDeviceTypeId:(NSString *)deviceTypeId success:(successBlock)success failure:(failureBlock)failure; c、初始化HETBLEBusiness对象，启动绑定流程 //初始化蓝牙设备的业务类，需要设备的productId，deviceTypeId，deviceSubtypeId self.bleBusiness=[[HETBLEBusiness alloc] initWithProductId:self.productId.integerValue deviceTypeId:self.deviceTypeId.integerValue deviceSubtypeId:self.deviceSubtypeId.integerValue]; 扫描蓝牙设备,扫描到的蓝牙设备，用tableView显示出来，给用户选择。 WEAKSELF [self.bleBusiness scanForPeripheralsWithTimeOut:timeOut name:nil mac:nil scanForPeripheralsBlock:^(NSArray *peripherals, NSError *error) { if (error) { [weakSelf scanDeviceFail]; return ; } if (peripherals) { OPLog(@\"peripherals = %@\",peripherals); OPLog(@\"[NSThread currentThread] = %@\",[NSThread currentThread]); [peripherals enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) { }]; return; } }]; d、绑定设备 选择需要绑定的设备，启动绑定流程。 [self.bleBusiness bindBleDeviceWithPeripheral:cbp macAddress:nil completionHandler:^(NSString *deviceId, NSError *error) { [weakself.bleBusiness disconnectWithPeripheral:cbp]; if(error) { } else { } }]; "},"source/zh-cn/app/SDK/iOSSDK/iOS_Device_Share.html":{"url":"source/zh-cn/app/SDK/iOSSDK/iOS_Device_Share.html","title":"3.2.2.5 SDK蓝牙设备的控制","keywords":"","body":"IOS 设备分享 C-Life设备分享分为面对面分享和第三方应用分享,分享相关接口请参考HETDeviceShareBusiness 一、分享流程 面对面分享： A用户打开APP设备面对面分享产生一个分享二维码， B用户打开APP的扫一扫，直接获取设备的控制权限。 第三方应用分享： A用户打开APP设备第三方应用分享（微信，QQ），例如分享到微信好友， B用户识别微信中的二维码，打开分享网页，尝试打开APP成功即获取设备的控制权限，失败就提示用户B下载APP。 注意： 1、URL scheme 第三方分享需要APP提供URL scheme，方便web页面打开APP，并且传递分享码给APP。 2、分享码有效期 面对面分享码有效期为10分钟 第三方分享码有效期为一个小时 二、面对面分享 第一步：请求分享码，并生成分享二维码 第二步：验证分享码，获取设备权限 三、第三方应用分享 第一步：请求分享连接，分享到第三方应用 第二步：第三方应用打开连接，web页面尝试打开APP 第二步：验证分享码，获取设备权限 四、接口说明 1、分享 1.1、获取设备分享码 /** * 获取分享码 * * @param deviceId 分享的设备（加密的） * @param shareType 分享方式 （5 -面对面；6-远程分享） * @param success 成功的回调 * @param failure 失败的回调 */ +(void)getShareCodeWithDeviceId:(NSString *)deviceId shareType:(HETDeviceShareType)shareType success:(successBlock)success failure:(failureBlock)failure 参数说明 参数名称 是否必须 字段类型 参数说明 deviceId 是 NSString 设备ID shareType 是 HETDeviceShareType 分享类型 1.2、授权分享 /** * 授权分享 * * @param shareCode 分享码 * @param shareType 分享方式 （5 -面对面；6-远程分享） * @param success 成功的回调 * @param failure 失败的回调 */ +(void)authShareDeviceWithShareCode:(NSString *)shareCode shareType:(HETDeviceShareType)shareType success:(successBlock)success failure:(failureBlock)failure 参数说明 参数名称 是否必须 字段类型 参数说明 shareCode 是 NSString 设备分享码 shareType 是 HETDeviceShareType 分享类型 2.获取设备授权的用户列表 [HETDeviceShareBusiness deviceGetAuthUserWithDeviceId:self.deviceId success:^(id responseObject) { OPLog(@\"responseObject == %@\",responseObject); } failure:^(NSError *error) { OPLog(@\"error == %@\",error); }]; 3.用户设备授权删除 WEAKSELF [HETDeviceShareBusiness deviceAuthDelWithDeviceId:self.deviceId userId:userId success:^(id responseObject) { } failure:^(NSError *error) { }]; "},"source/zh-cn/app/SDK/iOSSDK/iOS_WIFI_Scan.html":{"url":"source/zh-cn/app/SDK/iOSSDK/iOS_WIFI_Scan.html","title":"3.2.2.6 SDK WIFI设备的扫描绑定","keywords":"","body":"wifi - 设备绑定 设备绑定概述 开放平台的设备按照功能划分类型，设备有大类，大类下面划分不同型号的小类。确定类型之后，设备还有WIFI和蓝牙设备之分。绑定设备之前首先就需要选择设备类型在扫描绑定。WIFI SSID和密码 需要开发者自己去获取手机当前连接的WIFI，让用户自己输入WIFI密码之后再调用开始扫描绑定的接口，productId是设备小类中productId字段。 设备绑定分为手动绑定和二维码扫描绑定，流程如下： 一、扫描二维码绑定 二维码命名规则： http://open.clife.net/v1/web/open/product?param={\"a\":产品id} 1、获取设备类型、确定设备绑定方式 通过扫一扫获取产品ID productId 根据 产品ID 获取设备信息 根据设备信息区分设备类型、设备绑定方式 a、获取产品ID 扫一扫内容： urlStr: http://open.clife.net/v1/web/open/product?param={\"a\":3531} \"a\":3531 3531 即是 产品ID b、根据 产品ID 获取设备信息 /** * 根据productId获取产品的详细信息 * * @param productId 设备型号标识 * @param success 查询设备信息成功的回调 * @param failure 查询设备信息失败的回调 */ +(void)fetchDeviceInfoWithProductId:(NSNumber *)productId success:(successBlock)success failure:(failureBlock)failure; 根据设备信息中的 moduleType 来区分设备类型 moduleType 绑定类型 1 wifi设备 SmartLink绑定 2 蓝牙设备 9 wifi设备 AP绑定 蓝牙设备暂时只有一种绑定方式（蓝牙绑定） 2、wifi 绑定 2.1 wifi smartLink绑定 在开始配置前，设备要先进入配置模式，然后APP发送要配置的路由器ssid和密码,开启扫描设备服务将扫描到的设备进行绑定，获取绑定结果回调。 第一步：获取路由器ssid和密码 第二步：传入参数产品ID productId，路由器ssid 和 密码，启动绑定流程 a、通过 HETWIFIBindBusiness 获取路由器ssid /** * 获得所连Wi-Fi的Mac地址 * * @return 返回mac地址 */ -(NSString *)fetchmacSSIDInfo; b、传入参数，通过 HETWIFIBindBusiness 调用接口， 启动绑定 /** * 绑定SmartLink模式WiFi设备 * * @param productId 设备的productId * @param ssid 设备所需要接入的路由器名称 * @param password 设备所需要接入的路由器密码 * @param interval 绑定的超时时间,单位是秒 * @param handler 绑定的回调 */ -(void)startSmartLinkBindDeviceWithProductId:(NSString *)productId withSSID:(NSString *)ssid withPassWord:(NSString *)password withTimeOut:(NSTimeInterval)interval bindHandler:(void (^)(HETWiFiDeviceBindState state,HETDevice *deviceObj, NSError *error))handler; 2.2 wifi AP绑定 在开始配置前，设备进入配置模式后，会产生一个Wifi热点。手机连接设备热点，将发送要配置的路由器ssid和密码给设备，然后APP将配置信息给设备，之后设备自行于服务器绑定，APP想服务器查询绑定状态。 使用C-life提供的模组固件，设备产生的Wifi热点以“HET-xxx”开头，没有密码。其他厂商提供的模组，SoftAP热点名称由各自厂商指定。 AP绑定的交互流程： 获取路由器ssid和密码 手机连接路由器热点 手机切换设备热点 传入参数 产品ID productId、设备大类ID、设备小类ID、路由器ssid 和 密码，启动绑定流程 a、传入参数，通过 HETWIFIBindBusiness 调用接口， 启动绑定 /** * 绑定AP模式的WiFi设备 * * @param productId 设备型号标识 * @param deviceTypeId 设备的大类 * @param deviceSubtypeId 设备的小类 * @param ssid AP设备所需要接入的路由器名称 * @param password AP设备所需要接入的路由器密码 * @param interval 绑定的超时时间,单位是秒 * @param handler 绑定的回调 */ -(void)startAPBindDeviceWithProductId:(NSString *)productId withDeviceTypeId:(NSUInteger)deviceTypeId withDeviceSubtypeId:(NSUInteger )deviceSubtypeId withSSID:(NSString *)ssid withPassWord:(NSString *)password withTimeOut:(NSTimeInterval)interval bindHandler:(void (^)(HETWiFiDeviceBindState state,HETDevice *deviceObj, NSError *error))handler; 二、手动绑定 1. smartLink 绑定 获取设备大类列表 (获取deviceTypeId) 获取设备小类列表（支持的设备列表,其中含有productId） 获取路由器ssid和密码 传入参数 产品ID productId、路由器ssid 和 密码，启动绑定流程 a、获取设备大类列表 在 HETDeviceRequestBusiness 查询设备信息获取相关接口 /** * 查询设备大类 * * @param success 成功的回调 * @param failure 失败的回调 */ + (void)fetchDeviceTypeListSuccess:(successBlock)success failure:(failureBlock)failure; b、通过大类ID，获取设备小类 /** * 根据设备大类查询APP支持的设备型号 * * @param success 成功的回调 * @param failure 失败的回调 */ + (void)fetchDeviceProductListWithDeviceTypeId:(NSString *)deviceTypeId success:(successBlock)success failure:(failureBlock)failure; c、通过 HETWIFIBindBusiness 获取路由器ssid /** * 获得所连Wi-Fi的Mac地址 * * @return 返回mac地址 */ -(NSString *)fetchmacSSIDInfo; d、传入参数，通过 HETWIFIBindBusiness 调用接口， 启动绑定 /** * 绑定SmartLink模式WiFi设备 * * @param productId 设备的productId * @param ssid 设备所需要接入的路由器名称 * @param password 设备所需要接入的路由器密码 * @param interval 绑定的超时时间,单位是秒 * @param handler 绑定的回调 */ -(void)startSmartLinkBindDeviceWithProductId:(NSString *)productId withSSID:(NSString *)ssid withPassWord:(NSString *)password withTimeOut:(NSTimeInterval)interval bindHandler:(void (^)(HETWiFiDeviceBindState state,HETDevice *deviceObj, NSError *error))handler; 2. AP 绑定 获取设备大类列表 (获取deviceTypeId) 获取设备小类列表（支持的设备列表,其中含有productId） 获取路由器ssid和密码 引导用户跳转到wifi连接页面，连接设备，待用户连接成功后，返回绑定页面 传入参数 产品ID productId、设备大类ID、设备小类ID、路由器ssid 和 密码，启动绑定流程 a、校验用户是否连接设备 设备AP热点命名规则： radiocastName_deviceTypeId_deviceSubtypeId 当判断用户已经成功连接设备AP热点，即可进入绑定流程。 b、传入参数，通过 HETWIFIBindBusiness 调用接口， 启动绑定 /** * 绑定AP模式的WiFi设备 * * @param productId 设备型号标识 * @param deviceTypeId 设备的大类 * @param deviceSubtypeId 设备的小类 * @param ssid AP设备所需要接入的路由器名称 * @param password AP设备所需要接入的路由器密码 * @param interval 绑定的超时时间,单位是秒 * @param handler 绑定的回调 */ -(void)startAPBindDeviceWithProductId:(NSString *)productId withDeviceTypeId:(NSUInteger)deviceTypeId withDeviceSubtypeId:(NSUInteger )deviceSubtypeId withSSID:(NSString *)ssid withPassWord:(NSString *)password withTimeOut:(NSTimeInterval)interval bindHandler:(void (^)(HETWiFiDeviceBindState state,HETDevice *deviceObj, NSError *error))handler; 绑定无法绑定？这里给出设备无法绑定的几种检查方法： 设备是否置为绑定模式，是否在绑定的有效时间内 是否正确输入wifi密码,请确认手机是否能正常连接网络 是扫描不到设备还是绑定不了设备,扫描失败会有对应提示是扫描不到设备，还是绑定不了设备 设备是否已在CLife开放平台注册，并按照要求将大小类信息写入设备中 "},"source/zh-cn/app/SDK/iOSSDK/iOS_WIFI_Controller.html":{"url":"source/zh-cn/app/SDK/iOSSDK/iOS_WIFI_Controller.html","title":"3.2.2.7 SDK WIFI设备的控制","keywords":"","body":"Wifi - 设备控制 参考HETDeviceControlBusiness类里面方法，实现设备控制和运行状态的监听。 参考HETDeviceRequestBusiness类里面的方法，获取设备的信息。 控制设备的流程如下：第一步：获取已绑定的设备列表，获取设备信息（HETDevice）。 第二步：根据获取的设备信息，监听设备状态，控制设备。 一、获取绑定设备列表 绑定成功后，用户可以获取绑定成功的设备列表，获取到设备列表拿到设备的HETDevice设备信息才可以控制设备 /** * 查询绑定的所有设备列表 * * @param success 设备列表返回HETDevice对象数组 * @param failure 失败的回调 */ + (void)fetchAllBindDeviceSuccess:(void (^)(NSArray* deviceArray))success failure:(failureBlock)failure; 二、监听设备状态 1、初始化 初始化HETDeviceControlBusiness的实例对象，传递需要监听的设备信息作为参数，监听block的回调信息，做相应的业务逻辑。对于运行数据、控制数据、错误数据的内容，请参考具体设备的配置协议内容。 - (HETDeviceControlBusiness *)controlBusiness { if (!_controlBusiness) { WEAKSELF _controlBusiness = [[HETDeviceControlBusiness alloc]initWithHetDeviceModel:self.device deviceRunData:^(id responseObject) { // 监听设备运行数据，responseObject请具体参考协议配置。 OPLog(@\"deviceRunData:%@ \" ,responseObject); } deviceCfgData:^(id responseObject) { // 监听设备控制数据 OPLog(@\"deviceCfgData:%@ \" ,responseObject); } deviceErrorData:^(id responseObject) { // 监听设备错误数据 OPLog(@\"deviceErrorData:%@ \" ,responseObject); } deviceState:^(HETWiFiDeviceState state) { // 监听设备在线状态数据 OPLog(@\"deviceState:%ld \" ,(long)state); //deviceState:2 }]; } return _controlBusiness; } 2、启动监听服务 - (void)viewWillAppear:(BOOL)animated { [self.controlBusiness start]; } 3、停止监听服务 - (void)viewWillDisappear:(BOOL)animated { [self.controlBusiness stop]; } 三、设备控制 设备控制流程入下： /** * 设备控制 * * @param jsonString 设备控制的json字符串,协议中的控制数据协议里面的字节属性名和对应值组成的字典经转换为json字符串,下发数据必须传递updateflag标志 * @param successBlock 控制成功的回调 * @param failureBlock 控制失败的回调 */ - (void)deviceControlRequestWithJson:(NSString *)jsonString withSuccessBlock:(void(^)(id responseObject))successBlock withFailBlock:(void(^)( NSError *error))failureBlock; 关于updateflag 这个修改标记位是为了做统计和配置下发的时候设备执行相应的功能。下发数据必须传递updateflag标志 例如，空气净化器（广磊K180）配置信息协议： 紫外线(1)、负离子(2)、臭氧(3)、儿童锁(4)、开关(5)、WiFi(6)、过滤网(7)、模式(8)、定时(9)、风量(10) 上面一共上10个功能，那么updateFlag就2个字节，没超过8个功能为1个字节，超过8个为2个字节，超过16个为3个字节，以此类推。 打开负离子，2个字节，每一个bit的值为下： 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 四：设备管理 1、解绑设备 设备删除有2中情况,需要自己根据设备分享类型（device.share）来区分： 第一种：设备是用户自己绑定的设备。调用unbindDeviceWithDeviceId: success: failure:来解除绑定。 /** * 解除设备绑定 * * @param deviceId 设备deviceId * @param success 成功的回调 * @param failure 失败的回调 */ [HETDeviceRequestBusiness unbindDeviceWithDeviceId:device.deviceId success:^(id responseObject) { } failure:^(NSError *error) { }]; 第二种：设备是别人分享的过来的设备。调用HetDeviceShareApi.getInstance().deviceDel()方法来解绑分享关系。 [HETDeviceShareBusiness deviceAuthDelWithDeviceId:device.deviceId userId:@\"\" success:^(id responseObject) { } failure:^(NSError *error) { }]; 2、修改设备信息 修改设备信息，用户可以修改设备的名称 /** * 修改设备基础信息 * * @param deviceId 设备标识 * @param deviceName 设备名称 * @param roomId 房间标识（绑定者才可以修改房间位置） * @param success 成功的回调 * @param failure 失败的回调 */ - (void)updateDeviceInfoWithDeviceId:(NSString *)deviceId deviceName:(NSString *)deviceName roomId:(NSString *)roomId success:(successBlock)success failure:(failureBlock)failure; "},"source/zh-cn/app/SDK/H5.html":{"url":"source/zh-cn/app/SDK/H5.html","title":"3.2.3 H5 SDK","keywords":"","body":"hetsdk说明文档 目录 项目开发及发布规范 项目开发 项目发布 项目开发 项目开发目录(推荐) + page // app设备html文件 + index.html + src // 工程源文件，代码编写在此目录进行 + css + js + static // 构建完成的工程文件，请勿直接编辑 + css + img + js + vm // 用于模拟app环境的虚拟器 项目开发注意细节 1.使用sdk开发时请登记repaint方法的回调函数,否则将无法获取app推送过来的数据。 2.向app发送数据时请携带updateFlag参数，并正确计算，否则可能导致下发指令失败。 3.sdk约定app推送过来的数据type=0为控制数据，type=1为运行数据。 项目发布 项目文件发布 项目发布目录结构 page // app设备html文件 index.html(必须) static // 构建完成的工程文件，请勿直接编辑 css img js 文件后缀 为便于sdk识别,项目文件需打包放在一个zix压缩包内,如test.zix "},"source/zh-cn/device/":{"url":"source/zh-cn/device/","title":"4. 硬件开发","keywords":"","body":""},"source/zh-cn/cloudAPI/":{"url":"source/zh-cn/cloudAPI/","title":"5. 云API","keywords":"","body":""},"source/zh-cn/dataservice/":{"url":"source/zh-cn/dataservice/","title":"6. 数据服务","keywords":"","body":""}}